name: ADF Deploy

on:
  push:
  pull_request:

jobs:
  test:
    runs-on: [self-hosted, linux, new-runner]

    steps:
      - name: Clean workspace
        run: |
          # ã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒˆãƒ©ãƒ³ãƒŠãƒ¼ã®ãƒ¯ãƒ¼ã‚¯ã‚¹ãƒšãƒ¼ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          find ${{ github.workspace }} -mindepth 1 -maxdepth 1 \
            ! -name src \
            -exec sudo rm -rf {} +
          find ${{ github.workspace }}/src -mindepth 1 -maxdepth 1 \
            ! -name dev \
            -exec sudo rm -rf {} +
          find ${{ github.workspace }}/src/dev -mindepth 1 -maxdepth 1 \
            ! -name pipeline \
            -exec sudo rm -rf {} +
          # pipelineãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé…ä¸‹ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚‚çµ¶å¯¾ã«æ¶ˆã•ãªã„ï¼ˆrmã‚„findã§pipelineé…ä¸‹ã‚’ä¸€åˆ‡è§¦ã‚‰ãªã„ï¼‰
          sudo find ${{ github.workspace }} -name ".pytest_cache" -type d -exec rm -rf {} + 2>/dev/null || true
          sudo find ${{ github.workspace }} -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
          sudo find ${{ github.workspace }} -name "*.pyc" -type f -delete 2>/dev/null || true
          
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Debug pipeline directory after checkout
        run: |
          echo "=== Files under src/dev after checkout ==="
          ls -lR ${{ github.workspace }}/src/dev/ || echo "No src/dev directory"
          echo "=== Files under src/dev/pipeline after checkout ==="
          ls -lR ${{ github.workspace }}/src/dev/pipeline/ || echo "No pipeline directory"
          echo "=== Git tracked files under src/dev/pipeline ==="
          git -C ${{ github.workspace }} ls-files src/dev/pipeline || echo "No tracked files in src/dev/pipeline"

      - name: Debug tests/unit directory after checkout
        run: |
          echo "=== tests/unit/ directory contents after checkout ==="
          ls -la ${{ github.workspace }}/tests/unit/

      - name: Fix file permissions
        run: |
          # ã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒˆãƒ©ãƒ³ãƒŠãƒ¼ã§ã®ãƒ•ã‚¡ã‚¤ãƒ«æ¨©é™å•é¡Œã‚’ä¿®æ­£
          sudo chown -R $USER:$USER ${{ github.workspace }}/
          sudo chmod -R 755 ${{ github.workspace }}/src/
          sudo chmod -R 644 ${{ github.workspace }}/src/dev/pipeline/*.json || true
          # pipelineãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªé…ä¸‹ã®æ‰€æœ‰è€…ãƒ»æ¨©é™ã‚‚æ˜ç¤ºçš„ã«ä¿®æ­£
          sudo chown -R $USER:$USER ${{ github.workspace }}/src/dev/pipeline
          sudo chmod -R 755 ${{ github.workspace }}/src/dev/pipeline
          echo "File permissions fixed"

      - name: Configure Docker Buildx
        run: |
          # Buildxç’°å¢ƒã®è¨­å®šã¨æ¤œè¨¼
          docker buildx create --use --name multiarch-builder || true
          docker buildx inspect --bootstrap
          docker buildx ls

      - name: Clean up existing containers
        run: |
          docker rm -f pytest-test azurite-test sqlserver-test || true
          docker network rm test-network || true

      - name: Create test network
        run: docker network create test-network

      - name: Start comprehensive E2E environment
        run: |
          echo "ğŸš€ Starting comprehensive E2E test environment..."
          
          # Start SQL Server with proper health check (matching docker-compose.e2e.yml)
          docker run -d --name sqlserver-test \
            --network test-network \
            -e 'ACCEPT_EULA=Y' \
            -e 'SA_PASSWORD=YourStrong!Passw0rd123' \
            -e 'MSSQL_PID=Express' \
            -e 'MSSQL_COLLATION=Japanese_CI_AS' \
            -p 1433:1433 \
            mcr.microsoft.com/mssql/server:2022-latest
          
          # Wait for SQL Server with proper health check
          echo "â³ Waiting for SQL Server to be ready..."
          for i in {1..15}; do
            if docker exec sqlserver-test /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'YourStrong!Passw0rd123' -Q 'SELECT 1' -C >/dev/null 2>&1; then
              echo "âœ… SQL Server is ready!"
              break
            fi
            echo "Waiting for SQL Server... attempt $i/15"
            sleep 5
          done
          
          # Initialize test databases
          echo "ğŸ—„ï¸ Initializing test databases..."
          docker exec sqlserver-test /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'YourStrong!Passw0rd123' -Q "CREATE DATABASE TGMATestDB COLLATE Japanese_CI_AS" -C || echo "Database may already exist"

      - name: Start Azurite service
        run: |
          docker run -d --name azurite-test \
            --network test-network \
            -e 'AZURITE_ACCOUNTS=devstoreaccount1:Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==' \
            -p 10000:10000 \
            -p 10001:10001 \
            -p 10002:10002 \
            mcr.microsoft.com/azure-storage/azurite:latest \
            azurite --blobHost 0.0.0.0 --queueHost 0.0.0.0 --tableHost 0.0.0.0 --location /data --debug /data/debug.log
      
      - name: Build test image
        run: docker build -t pytest-test .
      
      - name: Run test container with full environment
        run: |
          set -x
          # ã‚³ãƒ³ãƒ†ãƒŠèµ·å‹•ã‚³ãƒãƒ³ãƒ‰ã‚’ãƒ‡ãƒãƒƒã‚°å‡ºåŠ›ï¼ˆå®Œå…¨ãªç’°å¢ƒå¤‰æ•°ã‚»ãƒƒãƒˆï¼‰
          docker run -d --name pytest-test --network test-network \
            -e PYTHONPATH=/app \
            -e PYTHONUNBUFFERED=1 \
            -e PYTHONDONTWRITEBYTECODE=1 \
            -e TEST_MODE=e2e \
            -e LOG_LEVEL=INFO \
            -e SQL_SERVER_HOST=sqlserver-test \
            -e SQL_SERVER_PORT=1433 \
            -e E2E_SQL_SERVER=sqlserver-test,1433 \
            -e E2E_SQL_DATABASE=TGMATestDB \
            -e E2E_SQL_USERNAME=sa \
            -e E2E_SQL_PASSWORD=YourStrong!Passw0rd123 \
            -e AZURITE_HOST=azurite-test \
            -e AZURITE_ENDPOINT=http://azurite-test:10000 \
            -e AZURITE_CONNECTION_STRING='DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://azurite-test:10000/devstoreaccount1;' \
            -e GITHUB_ACTIONS=true \
            -v "${{ github.workspace }}/tests:/app/tests" \
            -v "${{ github.workspace }}/src:/app/src" \
            -v "${{ github.workspace }}/config:/app/config" \
            -v "${{ github.workspace }}/input:/app/input" \
            -v "${{ github.workspace }}/output:/app/output" \
            pytest-test tail -f /dev/null || { echo 'docker run failed'; exit 1; }
          echo "Container ID: $(docker ps -aqf 'name=pytest-test')"
      
      - name: Ensure pipeline files are accessible
        run: |
          echo "=== Host directory structure verification ==="
          echo "Workspace root contents:"
          ls -la ${{ github.workspace }}/ | head -10
          echo "src directory:"
          ls -la ${{ github.workspace }}/src/
          echo "src/dev directory:"
          ls -la ${{ github.workspace }}/src/dev/
          echo "=== Host pipeline directory detailed check ==="
          echo "Pipeline directory contents:"
          ls -la ${{ github.workspace }}/src/dev/pipeline/
          echo "Pipeline directory file count:"
          ls -1 ${{ github.workspace }}/src/dev/pipeline/ | wc -l
          echo "JSON files specifically:"
          ls -la ${{ github.workspace }}/src/dev/pipeline/*.json || echo "No JSON files found"
          echo "First 5 JSON files:"
          ls ${{ github.workspace }}/src/dev/pipeline/*.json 2>/dev/null | head -5 || echo "No JSON files to list"
          echo "=== File permissions check ==="
          ls -la ${{ github.workspace }}/src/dev/pipeline/ | grep "\.json" | head -3
          echo "=== Directory permissions ==="
          ls -ld ${{ github.workspace }}/src/dev/pipeline/
          echo "=== Container pipeline file access test ==="
          docker exec pytest-test ls -la /tests/src/dev/pipeline/ || echo "No /tests/src/dev/pipeline directory"
          docker exec pytest-test ls -la /app/src/dev/pipeline/ || echo "No /app/src/dev/pipeline directory"
          echo "=== Container JSON files direct check ==="
          docker exec pytest-test find /tests/src/dev/pipeline/ -name "*.json" -ls 2>/dev/null || echo "No JSON files in /tests mount"
          docker exec pytest-test find /app/src/dev/pipeline/ -name "*.json" -ls 2>/dev/null || echo "No JSON files in /app mount"
          echo "=== Running pipeline path initialization ==="
          docker exec pytest-test bash /app/docker/init-pipeline-paths.sh
          echo "=== Final verification ==="
          docker exec pytest-test ls -la /app/src/dev/pipeline/ | head -5
          docker exec pytest-test ls -la /tests/src/dev/pipeline/ | head -5
      
      - name: Wait for Azurite to be ready
        run: |
          echo "Waiting for Azurite to start up..."
          sleep 15
      
      - name: Verify test environment
        run: |
          echo "=== Python Environment ==="
          docker exec pytest-test bash -c "
            python --version && \
            pip list | grep pytest
          "
          echo "=== Test Directory Structure ==="
          docker exec pytest-test ls -la /tests/
          echo "=== Source Directory Structure ==="
          docker exec pytest-test ls -la /tests/src/ || echo "No /tests/src directory"
          docker exec pytest-test ls -la /tests/src/dev/ || echo "No /tests/src/dev directory"
          docker exec pytest-test ls -la /tests/src/dev/pipeline/ || echo "No /tests/src/dev/pipeline directory"          echo "=== Host Source Directory Check ==="
          ls -la ${{ github.workspace }}/src/dev/
          echo "=== Host Pipeline Directory Check ==="
          ls -la ${{ github.workspace }}/src/dev/pipeline/ || echo "No pipeline directory on host"
          echo "=== Working Directory ==="
          docker exec pytest-test pwd
          echo "=== Network Connectivity ==="
          docker exec pytest-test curl -f http://azurite-test:10000/devstoreaccount1 || echo 'Azurite connection failed'

      - name: DBåˆæœŸåŒ–ï¼ˆpyodbcçµŒç”±ãƒ»pytest-testã‚³ãƒ³ãƒ†ãƒŠï¼‰- æ¡ä»¶ä»˜ãå®Ÿè¡Œ
        run: |
          # TODO: æŠ€è¡“çš„è² å‚µ - pyodbcä¾å­˜ã®DBåˆæœŸåŒ–ã‚’æ¡ä»¶åˆ†å²ã§å›é¿ã—ã¦ã„ã‚‹
          # ç†æƒ³çš„ã«ã¯ä»¥ä¸‹ã®ã„ãšã‚Œã‹ã®å¯¾å¿œãŒå¿…è¦:
          # 1. pyodbcéä¾å­˜ã®DBåˆæœŸåŒ–ã‚¹ã‚¯ãƒªãƒ—ãƒˆï¼ˆSQLAlchemy/requestsçµŒç”±ï¼‰ã®ä½œæˆ
          # 2. è»½é‡Dockerã‚¤ãƒ¡ãƒ¼ã‚¸ã«pyodbc + ODBC Driver 18ã®è¿½åŠ 
          # 3. SQLãƒ•ã‚¡ã‚¤ãƒ«å®Ÿè¡Œã®ãŸã‚ã®ã‚·ã‚§ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆåŒ–ï¼ˆsqlcmdçµŒç”±ï¼‰
          # ç¾åœ¨ã¯æ¡ä»¶ä»˜ãã‚¹ã‚­ãƒƒãƒ—ã§å›é¿ã—ã¦ã„ã‚‹ãŒã€å®Œå…¨ãªDBåˆæœŸåŒ–ãƒ†ã‚¹ãƒˆã«ã¯é™ç•ŒãŒã‚ã‚‹
          
          # pyodbcãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
          if docker exec pytest-test python -c "import pyodbc; print('âœ… pyodbc available')" 2>/dev/null; then
            echo "ğŸ”§ pyodbc is available, proceeding with DB initialization"
            cat <<'EOF' > init_db.py
          import pyodbc, re, sys, traceback

          def exec_sqlfile(path, conn):
              print(f"ğŸ”§ Executing SQL file: {path}")
              try:
                  with open(path, encoding='utf-8') as f:
                      sql = f.read()
                  print(f"âœ… Successfully read {len(sql)} characters from {path}")
                  
                  # è¡Œé ­ãƒ»è¡Œæœ«ã®GOã§åˆ†å‰²
                  statements = re.split(r'(?im)^\s*GO\s*$', sql)
                  print(f"ğŸ“ Split into {len(statements)} SQL statements")
                  
                  for i, stmt in enumerate(statements):
                      stmt = stmt.strip()
                      if stmt:
                          try:
                              cursor = conn.cursor()
                              cursor.execute(stmt)
                              conn.commit()
                              print(f"   âœ… Statement {i+1} executed successfully")
                          except Exception as e:
                              print(f"   âŒ Statement {i+1} failed: {e}")
                              print(f"   ğŸ“„ Statement content (first 200 chars): {stmt[:200]}...")
                              # Continue with next statement instead of failing completely
                              continue
                  print(f"ğŸ‰ Completed processing {path}")
              except Exception as e:
                  print(f"âŒ Failed to process {path}: {e}")
                  traceback.print_exc()

          # æ¥ç¶šç¢ºèªã¨ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ã‚’è¿½åŠ 
          print("ğŸ”— Attempting to connect to SQL Server...")
          max_retries = 5
          for attempt in range(max_retries):
              try:
                  conn = pyodbc.connect('DRIVER={ODBC Driver 18 for SQL Server};SERVER=sqlserver-test,1433;DATABASE=TGMATestDB;UID=sa;PWD=YourStrong!Passw0rd123;TrustServerCertificate=yes', timeout=30)
                  print(f"âœ… Connected to SQL Server on attempt {attempt + 1}")
                  break
              except Exception as e:
                  print(f"âš ï¸ Connection attempt {attempt + 1} failed: {e}")
                  if attempt < max_retries - 1:
                      import time
                      time.sleep(5)
                  else:                      print("âŒ Failed to connect after all retries")
                      sys.exit(1)

          # å…¨ã¦ã®åˆæœŸåŒ–SQLãƒ•ã‚¡ã‚¤ãƒ«ã‚’é †åºé€šã‚Šå®Ÿè¡Œ
          sql_files = [
              '/app/docker/sql/init/00_create_synapse_db_fixed.sql',
              '/app/docker/sql/init/01_init_database_fixed.sql', 
              '/app/docker/sql/init/02_create_test_tables_simple.sql',
              '/app/docker/sql/init/03_insert_test_data.sql',
              '/app/docker/sql/init/04_enhanced_test_tables.sql',
              '/app/docker/sql/init/05_comprehensive_test_data.sql',
              '/app/docker/sql/init/06_additional_e2e_test_data.sql'
          ]
          
          print(f"ğŸš€ Starting DB initialization with {len(sql_files)} SQL files...")
          for sql_file in sql_files:
              exec_sqlfile(sql_file, conn)
          
          # ãƒ†ãƒ¼ãƒ–ãƒ«å­˜åœ¨ç¢ºèª
          print("ğŸ” Verifying table creation...")
          cursor = conn.cursor()
          try:
              cursor.execute("SELECT COUNT(*) FROM dbo.client_dm")
              client_count = cursor.fetchone()[0]
              print(f"âœ… client_dm table has {client_count} records")
              
              cursor.execute("SELECT COUNT(*) FROM etl.e2e_test_execution_log")
              e2e_count = cursor.fetchone()[0] 
              print(f"âœ… e2e_test_execution_log table has {e2e_count} records")  
              cursor.execute("SELECT COUNT(*) FROM dbo.client_dm WHERE client_id LIKE 'E2E_%'")
              e2e_client_count = cursor.fetchone()[0]
              print(f"âœ… E2E client_dm records: {e2e_client_count}")
              
          except Exception as e:
              print(f"âš ï¸ Table verification failed: {e}")
          
          conn.close()
          print('ğŸ‰ DB initialization completed successfully')
          EOF
            docker cp init_db.py pytest-test:/app/init_db.py
            docker exec pytest-test python /app/init_db.py
          else
            echo "âš ï¸ pyodbc not available in container - skipping DB initialization"
            echo "â„¹ï¸ DB-dependent tests will be automatically skipped during test execution"
          fi

      - name: Wait for SQL Server ready (pyodbc) - æ¡ä»¶ä»˜ãå®Ÿè¡Œ
        run: |
          # TODO: æŠ€è¡“çš„è² å‚µ - SQL Serveræ¥ç¶šç¢ºèªã‚‚pyodbcä¾å­˜
          # ä»£æ›¿æ¡ˆ: 
          # 1. sqlcmdã‚³ãƒãƒ³ãƒ‰ã«ã‚ˆã‚‹æ¥ç¶šç¢ºèªï¼ˆã‚³ãƒ³ãƒ†ãƒŠé–“é€šä¿¡ï¼‰
          # 2. curl/wgetã«ã‚ˆã‚‹SQL Server TCPãƒãƒ¼ãƒˆç¢ºèª
          # 3. dockerã‚³ãƒ³ãƒ†ãƒŠã®healthcheckã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
          # pyodbcãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
          if docker exec pytest-test python -c "import pyodbc; print('âœ… pyodbc available')" 2>/dev/null; then
            echo "ğŸ”§ pyodbc is available, proceeding with SQL Server readiness check"
            cat <<'EOF' > wait_sqlserver.py
          import time
          import pyodbc
          
          print("ğŸ”„ Waiting for SQL Server to be ready...")
          max_retries = 60  # å¢—åŠ : 60å› Ã— 3ç§’ = æœ€å¤§3åˆ†
          
          for i in range(max_retries):
              try:
                  # æ¥ç¶šãƒ†ã‚¹ãƒˆ - ã‚ˆã‚Šé•·ã„ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
                  conn = pyodbc.connect(
                      'DRIVER={ODBC Driver 18 for SQL Server};SERVER=sqlserver-test,1433;DATABASE=master;UID=sa;PWD=YourStrong!Passw0rd123;TrustServerCertificate=yes', 
                      timeout=10  # æ¥ç¶šã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã‚’10ç§’ã«å¢—åŠ 
                  )
                  
                  # TGMATestDBã®å­˜åœ¨ç¢ºèª
                  cursor = conn.cursor()
                  cursor.execute("SELECT name FROM sys.databases WHERE name = 'TGMATestDB'")
                  if cursor.fetchone():
                      print("âœ… TGMATestDB database found")
                  else:
                      print("âš ï¸ TGMATestDB database not found, creating...")
                      cursor.execute("CREATE DATABASE TGMATestDB")
                      conn.commit()                  
                  conn.close()
                  
                  # TGMATestDBã¸ã®æ¥ç¶šãƒ†ã‚¹ãƒˆ
                  test_conn = pyodbc.connect(
                      'DRIVER={ODBC Driver 18 for SQL Server};SERVER=sqlserver-test,1433;DATABASE=TGMATestDB;UID=sa;PWD=YourStrong!Passw0rd123;TrustServerCertificate=yes',
                      timeout=10
                  )
                  test_conn.close()
                  
                  print(f'âœ… SQL Server is ready (attempt {i+1}/{max_retries})')
                  break
              except Exception as e:
                  print(f'âš ï¸ Waiting for SQL Server... ({i+1}/{max_retries}): {e}')
                  time.sleep(3)  # å¾…æ©Ÿæ™‚é–“ã‚’3ç§’ã«å¢—åŠ 
          else:
              print('âŒ SQL Server did not become ready in time')
              raise RuntimeError('SQL Server did not become ready in time')
          EOF
            docker cp wait_sqlserver.py pytest-test:/app/wait_sqlserver.py
            docker exec pytest-test python /app/wait_sqlserver.py
          else
            echo "âš ï¸ pyodbc not available in container - skipping SQL Server readiness check"
            echo "â„¹ï¸ SQL Server dependent operations will be skipped"
          fi

      - name: Run pytest
        run: |
          docker exec pytest-test bash -c "            export PYTHONPATH=/app && \
            export AZURITE_HOST=azurite-test && \
            cd /app/tests && \
            python -m pytest unit/ -v --tb=short --no-header
          "

      - name: Run unit tests
        run: docker exec pytest-test pytest tests/unit --maxfail=1 --disable-warnings -q

      - name: Run e2e tests with comprehensive environment
        run: |
          echo "ğŸ§ª Running E2E tests with full environment setup..."
          
          # Verify all services are running
          echo "ğŸ“‹ Service status check:"
          docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
            # Test database connectivity with longer timeout (æ¡ä»¶ä»˜ã)
          echo "ğŸ” Testing database connectivity..."
          if docker exec sqlserver-test /opt/mssql-tools18/bin/sqlcmd -S localhost -U sa -P 'YourStrong!Passw0rd123' -Q "SELECT name FROM sys.databases" -C -t 30; then
            echo "âœ… SQL Server is accessible"
          else
            echo "âš ï¸ SQL Server connectivity test failed - DB-dependent tests will be skipped"
          fi
          
          # Test Azurite connectivity
          echo "ğŸ” Testing Azurite connectivity..."
          docker exec pytest-test curl -f http://azurite-test:10000/devstoreaccount1 || echo "Azurite connection test completed"
          
          # Pre-test database verification (æ¡ä»¶ä»˜ã)
          echo "ğŸ” Pre-test database verification..."
          if docker exec pytest-test python -c "import pyodbc; print('pyodbc available')" 2>/dev/null; then
            docker exec pytest-test python -c "
          import pyodbc
          try:
              conn = pyodbc.connect('DRIVER={ODBC Driver 18 for SQL Server};SERVER=sqlserver-test,1433;DATABASE=TGMATestDB;UID=sa;PWD=YourStrong!Passw0rd123;TrustServerCertificate=yes', timeout=30)
              cursor = conn.cursor()
              cursor.execute('SELECT COUNT(*) FROM dbo.client_dm WHERE client_id LIKE \'E2E_%\'')
              e2e_count = cursor.fetchone()[0]
              print(f'âœ… E2E client_dm records: {e2e_count}')
              cursor.execute('SELECT COUNT(*) FROM etl.e2e_test_execution_log')
              log_count = cursor.fetchone()[0]
              print(f'âœ… e2e_test_execution_log records: {log_count}')
              conn.close()
          except Exception as e:
              print(f'âš ï¸ Pre-test DB verification failed: {e}')
              print('â„¹ï¸ DB-dependent tests will be automatically skipped')
          "
          else
            echo "âš ï¸ pyodbc not available - skipping pre-test database verification"
          fi
            # Run E2E tests with all environment variables and extended timeout
          echo "ğŸš€ Starting E2E test execution..."
          docker exec pytest-test bash -c "
            export PYTHONPATH=/app && \
            export AZURITE_HOST=azurite-test && \
            export SQL_CONNECTION_TIMEOUT=30 && \
            cd /app && \
            pytest tests/e2e --maxfail=3 --disable-warnings -v --tb=short
          "

      - name: Get logs on failure
        if: failure()
        run: |
          echo "=== pytest-test container logs ==="
          docker logs pytest-test
          echo "=== Azurite service logs ==="
          docker logs azurite-test || echo "No azurite-test container found"
          echo "=== Container processes ==="
          docker exec pytest-test ps aux || true
          echo "=== Network information ==="
          docker network inspect test-network || true
          echo "=== Environment variables ==="
          docker exec pytest-test printenv | grep -E "(AZURITE|PYTHON)" || true
      
      - name: Cleanup
        if: always()
        run: |
          # Dockerãƒªã‚½ãƒ¼ã‚¹ã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—          docker rm -f pytest-test azurite-test sqlserver-test || true
          docker network rm test-network || true
          # ã‚»ãƒ«ãƒ•ãƒ›ã‚¹ãƒˆãƒ©ãƒ³ãƒŠãƒ¼ç”¨ã®è¿½åŠ ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
          sudo rm -rf tests/.pytest_cache/ || true
          sudo rm -rf tests/__pycache__/ || true
          sudo find . -name "*.pyc" -type f -delete 2>/dev/null || true
          sudo find . -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true

      - name: SQL Serverã‚³ãƒ³ãƒ†ãƒŠå†…ã®sqlcmdãƒ‘ã‚¹èª¿æŸ»
        run: |
          docker exec sqlserver-test which sqlcmd || docker exec sqlserver-test find / -name sqlcmd || echo 'sqlcmd not found'
